#include "otbImageFileReader.h"

#include "otbStreamingImageFileWriter.h"

#include "itkRescaleIntensityImageFilter.h"

 

#include "otbImage.h"

#include "otbVectorImage.h"

#include "itkConstShapedNeighborhoodIterator.h"

#include "itkNeighborhoodAlgorithm.h"

#include "itkImageRegionIterator.h"

#include "itkListSample.h"

#include "itkMeanCalculator.h"

#include "itkCovarianceCalculator.h"

#include "itkVariableSizeMatrix.h"

//#include "otbBSQImageIO.h"

 

//#define active_debug 1

//#define active_debug_loop 0

 

int main(int argc, char * argv[])

{

  typedef double PixelType;

  typedef otb::VectorImage<PixelType, 2> VectorImageType;

  typedef otb::Image<PixelType, 2> ImageType;

  typedef itk::ConstShapedNeighborhoodIterator<VectorImageType> ConstShapedNeighborhoodIteratorType;

  typedef itk::NeighborhoodAlgorithm::ImageBoundaryFacesCalculator<VectorImageType> VectorFaceCalculatorType;

  typedef itk::NeighborhoodAlgorithm::ImageBoundaryFacesCalculator<ImageType> FaceCalculatorType;

  typedef itk::ImageRegionIterator<ImageType> ImageRegionIteratorType;

  typedef VectorImageType::PixelType VectorMeasurementType;

  typedef itk::Statistics::ListSample<VectorMeasurementType> ListSampleType;

  typedef itk::Statistics::MeanCalculator<ListSampleType> MeanCalculatorType;

  typedef itk::Statistics::CovarianceCalculator<ListSampleType> CovarianceCalculatorType;

  typedef itk::VariableSizeMatrix<PixelType> MatrixType;

 

  typedef unsigned char WritePixelType;

  typedef otb::Image<WritePixelType> WriteImageType;

 

  typedef otb::ImageFileReader<VectorImageType> ReaderType;

  typedef otb::StreamingImageFileWriter<WriteImageType> WriterType;

  typedef itk::RescaleIntensityImageFilter<ImageType, WriteImageType> RescalerType;

 

  /////////// PARAMETRES ///////////

 

  const char * filename = argv[1];

  const char * outputFilename = argv[2];

  const int externalRadius = atoi(argv[3]);

  const int internalRadius = atoi(argv[4]);

 

 

  /////////// READER ///////////////

 

//          otb::BSQImageIO::Pointer BSQImageIO = otb::BSQImageIO::New();

  ReaderType::Pointer reader = ReaderType::New();

  reader->SetFileName(filename);

//          reader->SetImageIO(BSQImageIO);

 

  try

    {

    reader->Update();

    }

  catch(itk::ExceptionObject& err)

    {

    std::cout << "Erreur lors de l'ouverture du fichier " << err << std::endl;

    }

 

 

  ///////////// InPUT /////////////////

 

  VectorImageType::Pointer inputImage;

  inputImage = reader->GetOutput();

  inputImage->Update();

 

 

  ///////////// OUTPUT ////////////////

 

  ImageType::Pointer outputImage = ImageType::New();

  outputImage->SetRegions(inputImage->GetLargestPossibleRegion());

  outputImage->Allocate();

  outputImage->FillBuffer(0);

 

 

  /////////// ITERATOR ON INUPT IMAGE ////////////

 

  ConstShapedNeighborhoodIteratorType::RadiusType radius;

  radius.Fill(externalRadius);

 

  VectorFaceCalculatorType                         vectorFaceCalculator;

  VectorFaceCalculatorType::FaceListType           vectorFaceList;

  VectorFaceCalculatorType::FaceListType::iterator vectorFit;

 

  vectorFaceList = vectorFaceCalculator(inputImage, outputImage->GetRequestedRegion(), radius);

 

  vectorFit = vectorFaceList.begin();          // On utilise que la premiere face de la liste

 

  ConstShapedNeighborhoodIteratorType inputIt(radius, inputImage, *vectorFit);

 

 

  /////////// Neighborhood Configuration ///////////

 

  ConstShapedNeighborhoodIteratorType::OffsetType off;

 

  for (int y = -externalRadius; y <= externalRadius; y++)

    {

    off[1] = y;

    for (int x = -externalRadius; x <= externalRadius; x++)

      {

      off[0] = x;

      if ((abs(x) > internalRadius) || (abs(y) > internalRadius))

        {

        inputIt.ActivateOffset(off);

        }

      }

    }

 

 

  //////////// ITERATOR ON OUTPUT IMAGE ////////////

 

  FaceCalculatorType                         faceCalculator;

  FaceCalculatorType::FaceListType           faceList;

  FaceCalculatorType::FaceListType::iterator fit;

 

  faceList = faceCalculator(outputImage, outputImage->GetRequestedRegion(), radius);

 

  fit = faceList.begin();      // On utilise que la premiere face de la liste

 

  ImageRegionIteratorType outputIt(outputImage, *fit);

 

 

  /////////// Run Input Image ///////////////

 

  int j = 0;

 

  for (inputIt.GoToBegin(), outputIt.GoToBegin(); !inputIt.IsAtEnd(); ++inputIt, ++outputIt)

    {

 

    // Create ListSample

 

    ListSampleType::Pointer listSample = ListSampleType::New();

    listSample->SetMeasurementVectorSize(inputImage->GetNumberOfComponentsPerPixel());

 

 

    // Run neighborhood

 

    ConstShapedNeighborhoodIteratorType::ConstIterator ci;

    for (ci = inputIt.Begin(); !ci.IsAtEnd(); ++ci)

      {

      // Pushback element in listSample

      listSample->PushBack(ci.Get());

      }

 

 

    // Compute Mean vector

 

    MeanCalculatorType::Pointer meanCalculator = MeanCalculatorType::New();

    meanCalculator->SetInputSample(listSample);

    meanCalculator->Update();

 

    MeanCalculatorType::OutputType *meanVector;

    meanVector = meanCalculator->GetOutput();

 

 

    // Compute covariance matrix

 

    CovarianceCalculatorType::Pointer covarianceCalculator = CovarianceCalculatorType::New();

    covarianceCalculator->SetInputSample(listSample);

    covarianceCalculator->SetMean(meanVector);

    covarianceCalculator->Update();

 

    const CovarianceCalculatorType::OutputType *covarianceMatrix = covarianceCalculator->GetOutput();

 

 

    // Compute RX value

 

    MatrixType invCovMat;

    invCovMat = covarianceMatrix->GetInverse();

 

    VectorMeasurementType testPixVec;

    testPixVec = inputImage->GetPixel(inputIt.GetIndex());

 

    VectorMeasurementType meanVec(meanVector->GetNumberOfElements());

    for(unsigned int i = 0; i < meanVector->GetNumberOfElements(); i++)

      {

      meanVec.SetElement(i, meanVector->GetElement(i));

      }

 

    MatrixType::InternalMatrixType centeredTestPixMat(meanVector->GetNumberOfElements(), 1);

    for (unsigned int i = 0; i < centeredTestPixMat.rows() ;i++)

      {

      centeredTestPixMat.put(i, 0, (testPixVec.GetElement(i) - meanVector->GetElement(i)));

      }

 

    MatrixType::InternalMatrixType rxValue = centeredTestPixMat.transpose() * invCovMat.GetVnlMatrix() * centeredTestPixMat;

 

    outputIt.Set(rxValue.get(0,0));

 

    if (j%10 == 0)

      {

      std::cout << "Pixel " << j << " :  rx = " << rxValue.get(0,0) << std::endl;

      }

    j++;

 

    }

 

 

  //////////  RESCALING BEFORE WRITING  ///////////

 

  //WriteImageType::Pointer writeImage = WriteImageType::New();

  RescalerType::Pointer rescaler = RescalerType::New();

  rescaler->SetOutputMinimum(0);

  rescaler->SetOutputMaximum(255);

 

  rescaler->SetInput(outputImage);

 

 

  //////////  WRITE DETECTION MAP  ///////////

 

  WriterType::Pointer writer = WriterType::New();

  writer->SetFileName(outputFilename);

  writer->SetInput(rescaler->GetOutput());

  writer->Update();

 

  return EXIT_SUCCESS;

}
