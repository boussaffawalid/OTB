/*=========================================================================

  Program:   ORFEO Toolbox
  Language:  C++
  Date:      $Date$
  Version:   $Revision$


  Copyright (c) Centre National d'Etudes Spatiales. All rights reserved.
  See OTBCopyright.txt for details.


     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notices for more information.

=========================================================================*/
#ifndef __otbSatelliteRSR_txx
#define __otbSatelliteRSR_txx

#include "otbSatelliteRSR.h"


namespace otb
{

  template <class TPrecision, class TValuePrecision>
      SatelliteRSR<TPrecision,TValuePrecision>
  ::SatelliteRSR()
  {
    //m_RSR = VectorType::New();
  }


  template <class TPrecision, class TValuePrecision>
      void
      SatelliteRSR<TPrecision,TValuePrecision>
  ::Load(const std::string & filename)
  {
    //Parse 6S file Reduce spectral response
    //Begin by getting the number of band of the satellite
    //unsigned int nbBands= this->SetNbBands ( filename );
    std::ifstream fin(filename.c_str());
    //std::cout << fin <<std::endl;
    if ( fin.fail() ) {
      //return
      itkExceptionMacro(<<"Error opening file" << filename);
    }
    /*
    int NumLigne = 26; // Go to the line 27
 
    for (int i = 0; i < NumLigne; ++i)
      fin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
    */
    unsigned int columnsCounter = 1;
    unsigned int nbColumns = m_NbBands +2;
    
    for (unsigned int i=0; i < m_NbBands;++i)
    {
      SpectralResponsePointerType RSRBand = SpectralResponseType::New();
      m_RSR.push_back (RSRBand);
    }
    PrecisionType currentLambda;
    PrecisionType zenithalAngle;
    while(! fin.eof() )
    {
      
      fin >> currentLambda;
      fin >> zenithalAngle;
      
      for (unsigned int i=0; i < m_NbBands;++i)
      {
        std::pair <TPrecision,TValuePrecision > * currentPair=new std::pair <TPrecision,TValuePrecision >;
        currentPair->first = currentLambda;
        fin >> currentPair->second;
        m_RSR[i]->GetResponse().push_back(currentPair);
      }
    }
    fin.close();
    
    std::sort(m_RSR.begin(), m_RSR.end(), sort_band());
  }

  template <class TPrecision, class TValuePrecision>
      bool
          SatelliteRSR<TPrecision,TValuePrecision>
  ::Clear()
  {
    m_RSR.clear();
    return true;
  }

  template <class TPrecision, class TValuePrecision>
      int
          SatelliteRSR<TPrecision,TValuePrecision>
  ::Size() const
  {
    return m_RSR.size();
  }

  
  template <class TPrecision, class TValuePrecision>
      inline typename SatelliteRSR<TPrecision,TValuePrecision>
  ::ValuePrecisionType
      SatelliteRSR<TPrecision,TValuePrecision>
  ::operator()(const PrecisionType & lambda, const unsigned int numBand)
  {
    if ( numBand >= m_NbBands )
    {
      itkExceptionMacro(<<"There is no band num " << numBand<< " in the RSR vector!");
    }
    else
    {
      return (*(m_RSR[numBand]))(lambda);
    } 
    
  }
  
  
  template <class TPrecision, class TValuePrecision>
      void
          SatelliteRSR<TPrecision,TValuePrecision>
  ::PrintSelf(std::ostream& os, itk::Indent indent) const
  {
    Superclass::PrintSelf(os,indent);
    os<<std::endl;
    
    //typename VectorPairType::iterator it = m_RSR.begin();
    //it = m_RSR.at(0);
    for(typename RSRVectorType::const_iterator it = m_RSR.begin(); it != m_RSR.end(); it++)
    {
      os << "Band Nb: " << it - m_RSR.begin() << std::endl;
      (*it)->PrintSelf (os,indent);
      os << std::endl;
    }

//     it = m_RSR.begin();
    
    /*
    itk::PreOrderTreeIterator<DataTreeType> it(m_DataTree);
    it.GoToBegin();

    while (!it.IsAtEnd())
    {
      itk::PreOrderTreeIterator<DataTreeType> itParent = it;
      bool goesOn = true;
      while (itParent.HasParent() && goesOn )
      {
        os<<indent;
        goesOn = itParent.GoToParent();
      }
      os<<"+"<<it.Get(<)<std::endl;
      ++it;
    }
    */
  }
} // end namespace otb

#endif
