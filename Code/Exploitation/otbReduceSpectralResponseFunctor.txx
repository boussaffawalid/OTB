/*=========================================================================

  Program:   ORFEO Toolbox
  Language:  C++
  Date:      $Date$
  Version:   $Revision$


  Copyright (c) Centre National d'Etudes Spatiales. All rights reserved.
  See OTBCopyright.txt for details.


     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notices for more information.

=========================================================================*/
#ifndef __otbReduceSpectralResponse_txx
#define __otbReduceSpectralResponse_txx

#include "otbReduceSpectralResponseFunctor.h"

#include <algorithm>

namespace otb
{

  template <class TSpectralResponse ,class TRSR>
      ReduceSpectralResponseFunctor <TSpectralResponse ,TRSR>
  ::ReduceSpectralResponseFunctor()
  {
    //m_Response = VectorType::New();
  }

  

  template <class TSpectralResponse ,class TRSR>
      bool
          ReduceSpectralResponseFunctor<TSpectralResponse ,TRSR>
  ::Clear()
  {
    return ( m_InputSatRSR->Clear() & m_InputSpectralResponse->Clear() );
  }

  
  template <class TSpectralResponse ,class TRSR>
      inline typename ReduceSpectralResponseFunctor<TSpectralResponse ,TRSR>
  ::ValuePrecisionType
      ReduceSpectralResponseFunctor<TSpectralResponse ,TRSR>
  ::operator()(const unsigned int numBand)
  {
    if ( numBand >= m_InputSatRSR->GetNbBands() ) 
    {
       itkExceptionMacro(<< "There is no band num " << numBand << " in the RSR vector!(Size of the current RSR vector is " << m_InputSatRSR->GetNbBands() << ")" );
    }
    else {
      ValuePrecisionType res = 0;
      ValuePrecisionType response1;
      ValuePrecisionType response2;
      ValuePrecisionType inputRSR1;
      ValuePrecisionType inputRSR2;
    
      PrecisionType lambda1;
      PrecisionType lambda2;
    
//     std::cout << "parcours" << std::endl;
//     std::cout << m_InputSatRSR << std::endl;
//     std::cout << "Spectral RESPONSE US" << std::endl;
//     std::cout << m_InputSpectralResponse << std::endl;
      typename VectorPairType::const_iterator it;
      VectorPairType pairs = (m_InputSatRSR->GetRSR())[numBand]->GetResponse();
      it = pairs.begin();
//     std::cout << (*it)->first << " " << (*it)->second << std::endl;
     
      while ( it != pairs.end() -1 )
      {
      
        lambda1=(*it)->first;
        lambda2=(*(it+1))->first;
//       std::cout << lambda1 << std::endl;
//       std::cout << lambda2 << std::endl;
        inputRSR1=(*it)->second;
        inputRSR2=(*(it+1))->second;
      //std::cout << inputRSR1 << std::endl;
        response1 = (*m_InputSpectralResponse)( lambda1 ) * inputRSR1;
        response2 = (*m_InputSpectralResponse)( lambda2 ) * inputRSR2;
      
      //Compute the surface of the trapeze
//       std::cout << lambda1 << std::endl;
//       std::cout << lambda2 << std::endl;
//       std::cout << inputRSR1 << std::endl;
//       std::cout << inputRSR2 << std::endl;
//       std::cout << response1 << std::endl;
//       std::cout << response2 << std::endl;
        res += ( (response1 + response2)*( lambda2 - lambda1 ) ) / 2.0;  
        ++it;  
      }
      return res;
    }
    
  }
  
  template <class TSpectralResponse ,class TRSR>
      void
          ReduceSpectralResponseFunctor<TSpectralResponse ,TRSR>
  ::PrintSelf(std::ostream& os, itk::Indent indent) const
  {
    Superclass::PrintSelf(os,indent);
    os<<std::endl;
    m_InputSpectralResponse->PrintSelf(os,indent);    
    m_InputSatRSR->PrintSelf(os,indent);
  }
} // end namespace otb

#endif
