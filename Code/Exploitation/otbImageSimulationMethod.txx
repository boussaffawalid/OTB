/*=========================================================================

  Program:   ORFEO Toolbox
  Language:  C++
  Date:      $Date$
  Version:   $Revision$


  Copyright (c) Centre National d'Etudes Spatiales. All rights reserved.
  See OTBCopyright.txt for details.


     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notices for more information.

=========================================================================*/
#ifndef __otbImageSimulationMethod_txx
#define __otbImageSimulationMethod_txx

#include "otbImageSimulationMethod.h"

namespace otb
{

template <class TInputVectorData, class TSpatialisation, class TLabelMapToSimulatedImage, class TFTM, class TOutputImage>
ImageSimulationMethod< TInputVectorData, TSpatialisation, TLabelMapToSimulatedImage, TFTM, TOutputImage>
::ImageSimulationMethod()
{
   m_NumberOfComponentsPerPixel = 3;
   m_SatRSRFilename="";
   m_PathRoot="";
   m_Mean=0.0;
   m_Variance=1e-6;
}


template <class TInputVectorData, class TSpatialisation, class TLabelMapToSimulatedImage, class TFTM, class TOutputImage>
void
ImageSimulationMethod< TInputVectorData,  TSpatialisation,  TLabelMapToSimulatedImage, TFTM, TOutputImage>
::GenerateOutputInformation()
{
   Superclass::GenerateOutputInformation();
   
   OutputImageType * output = this->GetOutput();
   output->SetNumberOfComponentsPerPixel(m_NumberOfComponentsPerPixel);
   
}



template <class TInputVectorData, class TSpatialisation, class TLabelMapToSimulatedImage, class TFTM, class TOutputImage>
void
ImageSimulationMethod< TInputVectorData, TSpatialisation, TLabelMapToSimulatedImage, TFTM, TOutputImage>
::ThreadedProcessLabelObject( LabelObjectType * labelObject )
{
   ReduceSpectralResponseType::Pointer reduceSpectralResponse = ReduceSpectralResponseType::New();
   SatelliteRSRType::Pointer satRSR = SatelliteRSRType::New();
   //Compute the spectral response associated to this object.
   SpectralResponseType::Pointer readSpectrum = SpectralResponseType::New();
   bool hasPath=false;
   //Check if the spectrum associated to this object is given by a database.
   for(unsigned int i=0; i<labelObject->GetNumberOfAttributes();i++)
   {
      if(labelObject->GetAvailableAttributes()[i].compare("path")==0) hasPath=true;
   }
   if(hasPath==true)
   {
      std::cout<<"had path : "<< m_PathRoot + labelObject->GetAttribute("path") << std::endl;
      readSpectrum->Load( m_PathRoot + labelObject->GetAttribute("path"),100 );
      reduceSpectralResponse->SetInputSpectralResponse(readSpectrum);
   }
   else //compute the spectrum using ProSail
   {
      ProspectModelType::Pointer prospectModel = ProspectModelType::New();
      SailModelType::Pointer sailModel = SailModelType::New();
      LeafParametersType::Pointer leafParams = LeafParametersType::New();
      
      //TODO faire un filtre qui calcul les paramètres à partir du field "area"
//       leafParams->SetCab(Cab);
//       leafParams->SetCar(Car);
//       leafParams->SetCBrown(CBrown);
//       leafParams->SetCw(Cw);
//       leafParams->SetCm(Cm);
//       leafParams->SetN(N);
      prospectModel->SetInput(leafParams);
//       sailModel->SetLAI(LAI);
//       sailModel->SetAngl(Angl);
//       sailModel->SetPSoil(PSoil);
//       sailModel->SetSkyl(Skyl);
//       sailModel->SetHSpot(HSpot);
//       sailModel->SetTTS(TTS);
//       sailModel->SetTTO(TTO);
//       sailModel->SetPSI(PSI);
      sailModel->SetReflectance(prospectModel->GetReflectance());
      sailModel->SetTransmittance(prospectModel->GetTransmittance());
      sailModel->Update();
      reduceSpectralResponse->SetInputSpectralResponse(sailModel->GetHorizontalReflectance());
   
   }
   //compute the satellite response of this spectrum
   
   satRSR->Clear();
   satRSR->SetNbBands(m_NumberOfComponentsPerPixel);
   satRSR->Load(m_SatRSRFilename);
   reduceSpectralResponse->SetInputSatRSR(satRSR);
   reduceSpectralResponse->CalculateResponse();

   typename InputLabelMapType::LabelObjectType::LineContainerType::const_iterator lit;
   typename InputLabelMapType::LabelObjectType::LineContainerType & lineContainer = labelObject->GetLineContainer();
   typename OutputImageType::PixelType pixel;
   pixel.SetSize(m_NumberOfComponentsPerPixel);
   
   //TODO a Changer
   RandomGeneratorType::Pointer randomGen = RandomGeneratorType::New();

   for( lit = lineContainer.begin(); lit != lineContainer.end(); lit++ )
   {
      IndexType idx = lit->GetIndex();
      unsigned long length = lit->GetLength();
      for( unsigned int i=0; i<length; i++)
      {
         //add gaussian white noise
         for(unsigned int i=0;i<m_NumberOfComponentsPerPixel;i++)
         {
            double ran = randomGen->GetNormalVariate(m_Mean,m_Variance);
            pixel[i]=static_cast<InternalPixelType>(reduceSpectralResponse->GetReduceResponse()->GetResponse()[i].second + ran);
         }
         this->GetOutput()->SetPixel( idx, pixel );
         idx[0]++;
      }
   }
   
}



template <class TInputVectorData, class TSpatialisation, class TLabelMapToSimulatedImage, class TFTM, class TOutputImage>
void
ImageSimulationMethod< TInputVectorData,  TSpatialisation, TLabelMapToSimulatedImage, TFTM, TOutputImage>
::PrintSelf(std::ostream& os, itk::Indent indent) const
{
   Superclass::PrintSelf(os, indent);
   
}

} //end namespace otb

#endif

