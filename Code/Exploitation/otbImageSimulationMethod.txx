/*=========================================================================

  Program:   ORFEO Toolbox
  Language:  C++
  Date:      $Date$
  Version:   $Revision$


  Copyright (c) Centre National d'Etudes Spatiales. All rights reserved.
  See OTBCopyright.txt for details.


     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notices for more information.

=========================================================================*/
#ifndef __otbImageSimulationMethod_txx
#define __otbImageSimulationMethod_txx

#include "otbImageSimulationMethod.h"

namespace otb
{

template <class TInputVectorData, class TSpatialisation, class TProspect, class TSail, class TFTM, class TOutputImage>
ImageSimulationMethod< TInputVectorData, TSpatialisation, TProspect, TSail, TFTM, TOutputImage>
::ImageSimulationMethod()
{
   //instanciation
   m_Spatialisation = SpatialisationType::New();
   m_Prospect = ProspectModelType::New();
   m_Sail = SailModelType::New();
   m_FTM = FTMType::New();
   
   //default value
   m_NumberOfComponentsPerPixel = 3;
   m_SatRSRFilename="";
   m_PathRoot="";
   m_Mean=0.0;
   m_Variance=1e-6;
}

// template <class TInputVectorData, class TSpatialisation, class TProspect, class TSail, class TFTM, class TOutputImage>
// void
// ImageSimulationMethod< TInputVectorData, TSpatialisation, TProspect, TSail, TFTM, TOutputImage>
// ::SetInput(const InputVectorDataType* object)
// {
//    this->itk::ProcessObject::SetNthInput(0,const_cast<InputVectorDataType *>(object));
// }
// 
// template <class TInputVectorData, class TSpatialisation, class TProspect, class TSail, class TFTM, class TOutputImage>
// typename ImageSimulationMethod<TInputVectorData, TSpatialisation, TProspect, TSail, TFTM, TOutputImage>::InputVectorDataType *
// ImageSimulationMethod< TInputVectorData, TSpatialisation, TProspect, TSail, TFTM, TOutputImage>
// ::GetInput()
// {
//    return static_cast<InputVectorDataType *>(this->itk::ProcessObject::GetInput(0));
// }


// template <class TInputVectorData, class TSpatialisation, class TProspect, class TSail, class TFTM, class TOutputImage>
// void
// ImageSimulationMethod< TInputVectorData, TSpatialisation, TProspect, TSail, TFTM, TOutputImage>
// ::GenerateOutputInformation()
// {
// //    Superclass::GenerateOutputInformation();
//    
//    OutputImageType * output = this->GetOutput();
//    
//    m_Spatialisation->SetInputVectorData(this->GetInput());
//    m_Spatialisation->UpdateOutputInformation();
//    
//    output->SetNumberOfComponentsPerPixel(m_NumberOfComponentsPerPixel);
//    
//    std::cout<<"output size : "<<m_Spatialisation->GetOutputImage()->GetLargestPossibleRegion().GetSize()<<std::endl;
//    output->SetLargestPossibleRegion(m_Spatialisation->GetOutputImage()->GetLargestPossibleRegion());
// }



template <class TInputVectorData, class TSpatialisation, class TProspect, class TSail, class TFTM, class TOutputImage>
void
ImageSimulationMethod< TInputVectorData, TSpatialisation, TProspect, TSail, TFTM, TOutputImage>
::GenerateData()
{
   std::cout<<"Generate data de SimulationMethod"<<std::endl;
//    InputVectorDataType * inputVectorData = this->GetInput();
   OutputImageType * outputImage = this->GetOutput();
   
   
   m_Spatialisation->SetInputVectorData(m_InputVectorData);
   m_Spatialisation->UpdateData();
   m_Spatialisation->GetOutputLabelMap()->Update();
//    m_Spatialisation->GetOutputLabelMap()->PrintLabelObjects();
   
   m_LabelObjectIterator = m_Spatialisation->GetOutputLabelMap()->GetLabelObjectContainer().begin();
   
   while(m_LabelObjectIterator != m_Spatialisation->GetOutputLabelMap()->GetLabelObjectContainer().end())
   {
      std::cout<<"WHILE"<<std::endl;
      LabelObjectType * labelObject = m_LabelObjectIterator->second;
      
      typename ReduceSpectralResponseType::Pointer reduceSpectralResponse = ReduceSpectralResponseType::New();
      typename SatelliteRSRType::Pointer satRSR = SatelliteRSRType::New();
      //Compute the spectral response associated to this object.
      typename SpectralResponseType::Pointer readSpectrum = SpectralResponseType::New();
      bool hasPath=false;
      //Check if the spectrum associated to this object is given by a database.
      for(unsigned int i=0; i<labelObject->GetNumberOfAttributes();i++)
      {
         if(labelObject->GetAvailableAttributes()[i].compare("path")==0) hasPath=true;
      }
      if(hasPath==true)
      {
         std::cout<<"had path : "<< m_PathRoot + labelObject->GetAttribute("path") << std::endl;
         readSpectrum->Load( m_PathRoot + labelObject->GetAttribute("path"),100 );
         reduceSpectralResponse->SetInputSpectralResponse(readSpectrum);
      }
      else //compute the spectrum using ProSail
      {
         typename ProspectModelType::Pointer prospectModel = ProspectModelType::New();
         typename SailModelType::Pointer sailModel = SailModelType::New();
         typename LeafParametersType::Pointer leafParams = LeafParametersType::New();
         
         //TODO faire un filtre qui calcul les paramètres à partir du field "area"
   //       leafParams->SetCab(Cab);
   //       leafParams->SetCar(Car);
   //       leafParams->SetCBrown(CBrown);
   //       leafParams->SetCw(Cw);
   //       leafParams->SetCm(Cm);
   //       leafParams->SetN(N);
         prospectModel->SetInput(leafParams);
   //       sailModel->SetLAI(LAI);
   //       sailModel->SetAngl(Angl);
   //       sailModel->SetPSoil(PSoil);
   //       sailModel->SetSkyl(Skyl);
   //       sailModel->SetHSpot(HSpot);
   //       sailModel->SetTTS(TTS);
   //       sailModel->SetTTO(TTO);
   //       sailModel->SetPSI(PSI);
         sailModel->SetReflectance(prospectModel->GetReflectance());
         sailModel->SetTransmittance(prospectModel->GetTransmittance());
         sailModel->Update();
         reduceSpectralResponse->SetInputSpectralResponse(sailModel->GetHorizontalReflectance());
      
      }
      //compute the satellite response of this spectrum
      
      satRSR->Clear();
      satRSR->SetNbBands(m_NumberOfComponentsPerPixel);
      satRSR->Load(m_SatRSRFilename);
      reduceSpectralResponse->SetInputSatRSR(satRSR);
      reduceSpectralResponse->CalculateResponse();
   
      typename LabelMapType::LabelObjectType::LineContainerType::const_iterator lit;
      typename LabelMapType::LabelObjectType::LineContainerType & lineContainer = labelObject->GetLineContainer();
      typename OutputImageType::PixelType pixel;
      pixel.SetSize(m_NumberOfComponentsPerPixel);
      
      //TODO a Changer
      RandomGeneratorType::Pointer randomGen = RandomGeneratorType::New();
   
      for( lit = lineContainer.begin(); lit != lineContainer.end(); lit++ )
      {
         IndexType idx = lit->GetIndex();
         unsigned long length = lit->GetLength();
         for( unsigned int i=0; i<length; i++)
         {
            //add gaussian white noise
            for(unsigned int i=0;i<m_NumberOfComponentsPerPixel;i++)
            {
               double ran = randomGen->GetNormalVariate(m_Mean,m_Variance);
               pixel[i]=static_cast<InternalPixelType>(reduceSpectralResponse->GetReduceResponse()->GetResponse()[i].second + ran);
            }
            outputImage->SetPixel( idx, pixel );
            idx[0]++;
         }
      }
      //treat a new object
      m_LabelObjectIterator++;
   }
}



template <class TInputVectorData, class TSpatialisation, class TProspect, class TSail, class TFTM, class TOutputImage>
void
ImageSimulationMethod< TInputVectorData,  TSpatialisation, TProspect, TSail, TFTM, TOutputImage>
::PrintSelf(std::ostream& os, itk::Indent indent) const
{
   Superclass::PrintSelf(os, indent);
   
}

} //end namespace otb

#endif

