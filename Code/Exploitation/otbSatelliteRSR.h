/*=========================================================================

  Program:   ORFEO Toolbox
  Language:  C++
  Date:      $Date$
  Version:   $Revision$


  Copyright (c) Centre National d'Etudes Spatiales. All rights reserved.
  See OTBCopyright.txt for details.


     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notices for more information.

=========================================================================*/
#ifndef __otbSatelliteRSR_h
#define __otbSatelliteRSR_h


#include "itkDataObject.h"
#include <itkObjectFactory.h>
#include <vector>
#include <utility>
#include <fstream>
#include <limits>

#include "otbSpectralResponse.h"

namespace otb
{
/** \class SatelliteRSR
   * \brief this class represents a hierarchy of vector data.
   *
   * This class contains an itk::TreeContainer templated with otb::DataNode.
   * It represents a tree structure of vector data. These data can be read from
   * shapefiles or kml files for instance.
   *
   * The internal tree can be walked with itk::TreeIteratorBase subclasses.
   *
   * The three templates indicate
   * - the precision of the points coordinates (by default: double)
   * - the number of dimensions of the space (by default: 2)
   * - the precision of the value associated with objects such as line or
   * polygons (by default: double)
   *
   * The elements in the SatelliteRSR have their coordinates in the projection
   * specified by the Wkt string. This class also offer the possibility to store
   * the coordinates directly into an image coordinate system, using the origin and
   * spacing in a similar way as the corresponding image.
   *
   * \sa DataNode
   * \sa SatelliteRSRFileReader
   * \sa SatelliteRSRFileWriter
   *
 */
template <class TPrecision = double, class TValuePrecision = double>
      class SatelliteRSR
  : public itk::DataObject
      {
        public:
          /** Standard class typedefs */
          typedef SatelliteRSR Self;
          typedef itk::DataObject Superclass;
          typedef itk::SmartPointer<Self> Pointer;
          typedef itk::SmartPointer<const Self> ConstPointer;



          /** Standard macros */
          itkNewMacro(Self);
          itkTypeMacro(SatelliteRSR,DataObject);
          
          itkGetConstMacro(NbBands, unsigned int);
          itkSetMacro(NbBands, unsigned int);
          
          //itkGetConstObjectMacro(RSR, RSRVectorType);
          //itkSetObjectMacro(RSR, RSRVectorType);
          /** Template parameters typedef */
          typedef TPrecision PrecisionType;
          typedef TValuePrecision ValuePrecisionType;
          
          //typedef std::pair<TPrecision,TValuePrecision> Pair;
          //typedef std::vector<Pair *> VectorPairType;
          typedef SpectralResponse <TPrecision,TValuePrecision>     SpectralResponseType;
          typedef typename SpectralResponseType::Pointer                SpectralResponsePointerType;
          typedef std::vector <SpectralResponsePointerType>         RSRVectorType;
          typedef typename SpectralResponseType::VectorPairType     VectorPairType;
          //itkGetConstReferenceMacro(Response, VectorType);

          
          /** Clear the vector data  */
          virtual bool Clear();

          /** Return the number of element in the tree */
          virtual int Size() const;

          /** Fill from a ASCII file (USGS now)*/
          void Load( const std::string & filename );
          
          /** Set the number of band of the satellite from an ASCII file *///TODO implement 
          //void SetNbBands (const std::string & filename);
          
          /** Compare RSR response (order bands)*/
          struct sort_band {
            bool operator() ( SpectralResponsePointerType  a , SpectralResponsePointerType  b )
            {
              PrecisionType aFirstNotNull;
              PrecisionType bFirstNotNull;
              
              typename VectorPairType::const_iterator it = a->GetResponse().begin();
                  
              while ((*it)->second == 0) 
              {
                ++it;  
              }
              aFirstNotNull = (*it)->first;
              
              typename VectorPairType::const_iterator it2 = b->GetResponse().begin();
                  
              while ((*it2)->second == 0) 
              {
                ++it2;  
              }
              bFirstNotNull = (*it2)->first;
              
              return  aFirstNotNull < bFirstNotNull;
            }
          };
          
          /**
           * \param PrecisionType
           * \param Band  
           * \return The interpolate value of the SR for the numBand (band n°0 to band n°(m_NbBands-1)).
           */
          inline ValuePrecisionType operator()(const PrecisionType & lambda, const unsigned int numBand);
          
          /** PrintSelf method */
          void PrintSelf(std::ostream& os, itk::Indent indent) const;
          
          /** get vector of RSR */
          RSRVectorType & GetRSR()
          {
            return m_RSR;
          }
        protected:
          /** Constructor */
          SatelliteRSR();
          /** Constructor from a ASCII file */
          //SatelliteRSR( const std::string & filename );
          /** Destructor */
          virtual ~SatelliteRSR() {};
          

        private:
          SatelliteRSR(const Self&); //purposely not implemented
          void operator=(const Self&); //purposely not implemented

          

          /** Spectral response (x=lambda; y=response)*/
          RSRVectorType    m_RSR;
          unsigned int m_NbBands;
      };
}// end namespace otb


#ifndef OTB_MANUAL_INSTANTIATION
#include "otbSatelliteRSR.txx"
#endif

#endif

