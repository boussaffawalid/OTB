/*=========================================================================

  Program:   ORFEO Toolbox
  Language:  C++
  Date:      $Date$
  Version:   $Revision$


  Copyright (c) Centre National d'Etudes Spatiales. All rights reserved.
  See OTBCopyright.txt for details.


     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notices for more information.

=========================================================================*/
#ifndef __otbSpectralResponse_txx
#define __otbSpectralResponse_txx

#include "otbSpectralResponse.h"

#include <algorithm>

namespace otb
{

  template <class TPrecision, class TValuePrecision>
      SpectralResponse<TPrecision,TValuePrecision>
  ::SpectralResponse()
  {
    //m_Response = VectorType::New();
  }

  template <class TPrecision, class TValuePrecision>
      void
      SpectralResponse<TPrecision,TValuePrecision>
  ::Load(const std::string & filename)
  {
    //Parse USGS file spectral response
    //Begin line 27
    std::ifstream fin(filename.c_str());
    //std::cout << fin <<std::endl;
    if ( fin.fail() ) {
      //return
      itkExceptionMacro(<<"Error opening file" << filename);
    }
    
    int NumLigne = 26; // Go to the line 27
 
    for (int i = 0; i < NumLigne; ++i)
      fin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
    
    while(! fin.eof() )
    {
      std::pair <TPrecision,TValuePrecision > * currentPair=new std::pair <TPrecision,TValuePrecision >;
      
      fin >> currentPair->first;
      fin >> currentPair->second;    
      
      //if ( currentPair->first > 10e-5 && currentPair->second > 10e-5 )
      if ( currentPair->first != 0 && currentPair->second != 0 )  
        m_Response.push_back(currentPair);
    }
    fin.close();
    
    std::sort(m_Response.begin(), m_Response.end(), sort_pair());
  }

  template <class TPrecision, class TValuePrecision>
      bool
          SpectralResponse<TPrecision,TValuePrecision>
  ::Clear()
  {
    m_Response.clear();
    return true;
  }

  template <class TPrecision, class TValuePrecision>
      int
          SpectralResponse<TPrecision,TValuePrecision>
  ::Size() const
  {
    return m_Response.size();
  }
  
  template <class TPrecision, class TValuePrecision>
  inline typename SpectralResponse<TPrecision,TValuePrecision>
  ::ValuePrecisionType
  SpectralResponse<TPrecision,TValuePrecision>
  ::operator()(const PrecisionType & lambda)
  {
    //ValuePrecisionType res;
    for(typename VectorPairType::const_iterator it = m_Response.begin(); it != m_Response.end() - 1; it++)
    {
      
      if ( (*it)->first == lambda ) {
        return (*it)->second; 
      }
      else if ( (*(it+1))->first == lambda ) {
        return (*(it+1))->second;
      } 
      else if ( ((*it)->first < lambda) && ((*(it+1))->first > lambda) )
      {
        PrecisionType l1 = (*it)->first;
        PrecisionType l2 = (*(it+1))->first;
        ValuePrecisionType s1 = (*it)->second;
        ValuePrecisionType s2 = (*(it+1))->second;
        /*
        std::cout << lambda << std::endl;
        std::cout << l1 << std::endl;
        std::cout << s1 << std::endl;
        std::cout << l2 << std::endl;
        std::cout << s2 << std::endl;    
        */
        return ((s2-s1)/(l2-l1)) * (lambda - l1) + s1 ;
      }
    }
    return 0;
  }
  
  template <class TPrecision, class TValuePrecision>
      void
          SpectralResponse<TPrecision,TValuePrecision>
  ::PrintSelf(std::ostream& os, itk::Indent indent) const
  {
    Superclass::PrintSelf(os,indent);
    os<<std::endl;
    
    //typename VectorPairType::iterator it = m_Response.begin();
    //it = m_Response.at(0);
    for(typename VectorPairType::const_iterator it = m_Response.begin(); it != m_Response.end(); it++)
    {
      os<<"Nb: "<< it - m_Response.begin() <<" // X: "<< (*it)->first << " Y: " << (*it)->second <<std::endl;
    }

//     it = m_Response.begin();
    
    /*
    itk::PreOrderTreeIterator<DataTreeType> it(m_DataTree);
    it.GoToBegin();

    while (!it.IsAtEnd())
    {
      itk::PreOrderTreeIterator<DataTreeType> itParent = it;
      bool goesOn = true;
      while (itParent.HasParent() && goesOn )
      {
        os<<indent;
        goesOn = itParent.GoToParent();
      }
      os<<"+"<<it.Get(<)<std::endl;
      ++it;
    }
    */
  }
} // end namespace otb

#endif
