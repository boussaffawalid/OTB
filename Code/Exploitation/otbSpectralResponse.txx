/*=========================================================================

  Program:   ORFEO Toolbox
  Language:  C++
  Date:      $Date$
  Version:   $Revision$


  Copyright (c) Centre National d'Etudes Spatiales. All rights reserved.
  See OTBCopyright.txt for details.


     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notices for more information.

=========================================================================*/
#ifndef __otbSpectralResponse_txx
#define __otbSpectralResponse_txx

#include "itkNumericTraits.h"


#include "otbSpectralResponse.h"

#include <algorithm>

namespace otb
{

template <class TPrecision, class TValuePrecision>
SpectralResponse<TPrecision,TValuePrecision>
::SpectralResponse()
{
//     m_Response = VectorType::New();
}

template <class TPrecision, class TValuePrecision>
void
SpectralResponse<TPrecision,TValuePrecision>
::Load(const std::string & filename, ValuePrecisionType coefNormalization)
{
    //Parse JPL file spectral response (ASCII file)
    //Begin line 27
    std::ifstream fin(filename.c_str());
    if ( fin.fail() ) {
      itkExceptionMacro(<<"Error opening file" << filename);
    }
    
    int NumLigne = 26; // Go to the line 27
    //Ignore first 26th lines which are metadatas informations
    for (int i = 0; i < NumLigne; ++i)
      fin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
    
    while(! fin.eof() )
    {
      //For each 
      std::pair<TPrecision,TValuePrecision > currentPair;
      
      fin >> currentPair.first;
      fin >> currentPair.second;
      currentPair.second = currentPair.second / coefNormalization;
      if ( currentPair.first != itk::NumericTraits<TPrecision>::ZeroValue() && currentPair.second != itk::NumericTraits<TValuePrecision>::ZeroValue() )  
       //Add not null pair of values to the vector
       m_Response.push_back(currentPair);
    }
    fin.close();
    //Sort the vector using the specific functor sort_pair
    std::sort(m_Response.begin(), m_Response.end(), sort_pair());
}

template <class TPrecision, class TValuePrecision>
bool
SpectralResponse<TPrecision,TValuePrecision>
::Clear()
{
   m_Response.clear();
   return true;
}

template <class TPrecision, class TValuePrecision>
unsigned int
SpectralResponse<TPrecision,TValuePrecision>
::Size() const
{
   return m_Response.size();
}

template <class TPrecision, class TValuePrecision>
inline typename SpectralResponse<TPrecision,TValuePrecision>::ValuePrecisionType
SpectralResponse<TPrecision,TValuePrecision>
::operator()(const PrecisionType & lambda)
{
    //Linear interpolation
    //Suppose that the vector is sorted
    for(typename VectorPairType::const_iterator it = m_Response.begin(); it != m_Response.end() - 1; it++)
    {
      
      if ( (*it).first == lambda ) {
        return (*it).second; 
      }
      else if ( (*(it+1)).first == lambda ) {
        return (*(it+1)).second;
      } 
      else if ( ((*it).first < lambda) && ((*(it+1)).first > lambda) )
      {
        PrecisionType l1 = (*it).first;
        PrecisionType l2 = (*(it+1)).first;
        ValuePrecisionType s1 = (*it).second;
        ValuePrecisionType s2 = (*(it+1)).second;
        // Compute the linear interpolation between the 2 pairs
        return ((s2-s1)/(l2-l1)) * (lambda - l1) + s1 ;
      }
    }
    //Value not available
    return 0;
}
  
template <class TPrecision, class TValuePrecision>
typename SpectralResponse<TPrecision,TValuePrecision>::ImagePointerType 
SpectralResponse<TPrecision,TValuePrecision>
::GetImage(ImagePointerType image) const
{
  typename ImageType::IndexType start;
  start[0] =  0;
  start[1] =  0;

  typename ImageType::SizeType  size;
//   size[0] = this->Size();
  size[0] = 1;
  size[1] = 1; 

  typename ImageType::PointType origin;
  origin[0] = 0;
  origin[1] = 0;

  typename ImageType::SpacingType spacing;
  spacing[0] = 1;
  spacing[1] = 1;

  typename ImageType::RegionType region;
  region.SetSize( size );
  region.SetIndex( start );


  image->SetRegions( region );
  image->SetNumberOfComponentsPerPixel( this->Size() );
  image->Allocate();

  typename ImageType::IndexType idx;
  typename ImageType::PixelType pixel;
  pixel.SetSize(this->Size());

  for ( unsigned int j=0 ;j<this->Size(); ++j )
  {
    pixel[j]=m_Response[j].second;
//     std::cout << "pixel[" <<j<<"] : "<< pixel[j] << std::endl;
  }
  
  idx[0]=0;
  idx[1]=0;
  image->SetPixel(idx,pixel);
  return image;
}

template <class TPrecision, class TValuePrecision>
void
SpectralResponse<TPrecision,TValuePrecision>
::SetFromImage(ImagePointerType image) 
{
  /*
  unsigned int i = 0;
  IteratorType iterator2( image, image->GetRequestedRegion() );
  for ( iterator2.GoToBegin(); !iterator2.IsAtEnd(); ++iterator2 )
  {
    m_Response[i]->second = iterator2.Get()[0];
    ++i;
  }
  */
  typename ImageType::IndexType idx;
  idx[0]=0;
  idx[1]=0;
//   typename ImageType::PixelType pixel;
//   pixel.Reserve( 1 );
  //pixel = itk::NumericTraits<typename ImageType::PixelType>::ZeroValue();
  //image->FillBuffer(pixel);
  for ( unsigned int j=0 ;j<this->Size(); ++j )
  {
    m_Response[j].second = image->GetPixel(idx)[j];
//     image->SetPixel( idx, pixel);
//     std::cout << "m_Response[j]->second " << m_Response[j]->second << std::endl;
//     std::cout << "image[j] " << image->GetPixel(idx).GetElement(0) << std::endl;
  }
}
  
template <class TPrecision, class TValuePrecision>
typename SpectralResponse<TPrecision,TValuePrecision>::FilterFunctionValuesPointerType 
SpectralResponse<TPrecision,TValuePrecision>
::GetFilterFunctionValues(double step) const
{
  
  //Assume that the SR is sorted
  typename FilterFunctionValuesType::ValuesVectorType valuesVector;
  for (double i =m_Response.front()->first; i <= m_Response.back()->first ;i+=step)
  {
    valuesVector.push_back=(*this)(i);
  }
  FilterFunctionValuesPointerType functionValues = FilterFunctionValuesType::New();
  
  functionValues->SetFilterFunctionValues(valuesVector);
  functionValues->SetMinSpectralValue(m_Response.front().first);
  functionValues->SetMaxSpectralValue(m_Response.back().first);
  functionValues->SetUserStep( step );
  
  return functionValues;
}

template <class TPrecision, class TValuePrecision>
std::pair< TPrecision, TPrecision>
SpectralResponse<TPrecision,TValuePrecision>
::GetInterval() const
{
  std::pair<TPrecision,TPrecision> res;
//   res.first=0;
//   std::cout <<"deb "  << std::endl;
  typename VectorPairType::const_iterator it = m_Response.begin();
  
  while ((*it).second == itk::NumericTraits<TValuePrecision>::ZeroValue()) 
  { 
//     std::cout <<"it "  << std::endl;
    ++it;
  }
  
  if (it == m_Response.begin())
  {
    res.first = (*it).first;
  }
  else
  {
    //std::cout <<"val "  << (*it)->first <<std::endl;
//     //--it;
    //std::cout <<"val apres "  << (*it)->first <<std::endl;
    res.first = (*(it-1)).first;
  }
  
  it = m_Response.end() - 1;
//   std::cout <<"end" <<std::endl;
  while ((*it).second == itk::NumericTraits<TValuePrecision>::ZeroValue()) 
  { 
//     std::cout <<"it2 "  << std::endl;
    --it;
  }
      
  if (it == m_Response.end())
  {
    res.second = (*it).first;
  }
  else
  {
    res.second = (*(it+1)).first;    
  }
  
//   std::cout << "res " << std::endl;
  
  return res;
}


template <class TPrecision, class TValuePrecision>
void
SpectralResponse<TPrecision,TValuePrecision>
::PrintSelf(std::ostream& os, itk::Indent indent) const
{
    Superclass::PrintSelf(os,indent);
    os<<std::endl;
    os <<indent << "[Wavelength (micrometers),Reflectance (percent)]" << std::endl;
   for(typename VectorPairType::const_iterator it = m_Response.begin(); it != m_Response.end(); ++it)
   {
     os <<indent << "Num "<< it - m_Response.begin() << ": [" << (*it).first << ","<< (*it).second << "]" << std::endl;
   }
}

} // end namespace otb

#endif
