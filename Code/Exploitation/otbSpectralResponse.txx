/*=========================================================================

  Program:   ORFEO Toolbox
  Language:  C++
  Date:      $Date$
  Version:   $Revision$


  Copyright (c) Centre National d'Etudes Spatiales. All rights reserved.
  See OTBCopyright.txt for details.


     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notices for more information.

=========================================================================*/
#ifndef __otbSpectralResponse_txx
#define __otbSpectralResponse_txx

#include "otbSpectralResponse.h"


namespace otb
{

  template <class TPrecision, class TValuePrecision>
      SpectralResponse<TPrecision,TValuePrecision>
  ::SpectralResponse()
  {
    //m_Response = VectorType::New();
  }

  template <class TPrecision, class TValuePrecision>
      void
      SpectralResponse<TPrecision,TValuePrecision>
  ::Load(const std::string & filename)
  {
    //Parse USGS file spectral response
    //Begin line 27
    std::ifstream fin(filename.c_str());
    //std::cout << fin <<std::endl;
    if ( fin.fail() ) {
      //return
      std::cout << "Error opening file";   
    }
    
    int NumLigne = 26; // Go to the line 27
 
    for (int i = 0; i < NumLigne; ++i)
      fin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
    
    while(! fin.eof() )
    {
      std::pair <TPrecision,TValuePrecision > * currentPair=new std::pair <TPrecision,TValuePrecision >;
      
      fin >> currentPair->first;
      fin >> currentPair->second;    
      
      //if ( currentPair->first > 10e-5 && currentPair->second > 10e-5 )
      if ( currentPair->first != 0 && currentPair->second != 0 )  
        m_Response.push_back(currentPair);
    }
    fin.close();
  }

  template <class TPrecision, class TValuePrecision>
      bool
          SpectralResponse<TPrecision,TValuePrecision>
  ::Clear()
  {
    m_Response.clear();
    return true;
  }

  template <class TPrecision, class TValuePrecision>
      int
          SpectralResponse<TPrecision,TValuePrecision>
  ::Size() const
  {
    return m_Response.size();
  }

  template <class TPrecision, class TValuePrecision>
      void
          SpectralResponse<TPrecision,TValuePrecision>
  ::PrintSelf(std::ostream& os, itk::Indent indent) const
  {
    Superclass::PrintSelf(os,indent);
    os<<std::endl;
    
    //typename VectorPairType::iterator it = m_Response.begin();
    //it = m_Response.at(0);
    for(typename VectorPairType::const_iterator it = m_Response.begin(); it != m_Response.end(); it++)
    {
      os<<"X: "<< (*it)->first << " Y: " << (*it)->second <<std::endl;
    }

//     it = m_Response.begin();
    
    /*
    itk::PreOrderTreeIterator<DataTreeType> it(m_DataTree);
    it.GoToBegin();

    while (!it.IsAtEnd())
    {
      itk::PreOrderTreeIterator<DataTreeType> itParent = it;
      bool goesOn = true;
      while (itParent.HasParent() && goesOn )
      {
        os<<indent;
        goesOn = itParent.GoToParent();
      }
      os<<"+"<<it.Get(<)<std::endl;
      ++it;
    }
    */
  }
} // end namespace otb

#endif
